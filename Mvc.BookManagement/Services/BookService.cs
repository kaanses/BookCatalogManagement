// Services/BookService.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using Microsoft.Extensions.Caching.Memory;using Mvc.BookManagement.Models.DTOs;using Mvc.BookManagement.Interfaces;using Serilog;using Mvc.BookManagement.Models.Entities;namespace Mvc.BookManagement.Services{    public class BookService : IBookService    {        private readonly IUnitOfWork _unitOfWork;        private readonly IMapper _mapper;        private readonly IValidator<BookInputDTO> _validator;        private readonly IMemoryCache _cache;        private const string BooksCacheKey = "AllBooks";        private const string BookCacheKeyPrefix = "Book_";        public BookService(            IUnitOfWork unitOfWork,             IMapper mapper,             IValidator<BookInputDTO> validator,            IMemoryCache cache)        {            _unitOfWork = unitOfWork;            _mapper = mapper;            _validator = validator;            _cache = cache;        }        public async Task<Result<IEnumerable<BookDTO>>> GetAllBooksAsync()        {            try            {                // Try to get from cache first                if (_cache.TryGetValue(BooksCacheKey, out IEnumerable<BookDTO> cachedBooks))                {                    Log.Information("Retrieved books from cache");                    return Result<IEnumerable<BookDTO>>.Success(cachedBooks);                }                // If not in cache, get from database                var books = await _unitOfWork.Repository<Book>().GetAllAsync();                var bookDtos = _mapper.Map<IEnumerable<BookDTO>>(books);                // Store in cache for 5 minutes                var cacheOptions = new MemoryCacheEntryOptions()                    .SetAbsoluteExpiration(TimeSpan.FromMinutes(5));                                _cache.Set(BooksCacheKey, bookDtos, cacheOptions);                                Log.Information("Retrieved all books from database");                return Result<IEnumerable<BookDTO>>.Success(bookDtos);            }            catch (Exception ex)            {                Log.Error(ex, "Error retrieving all books");                return Result<IEnumerable<BookDTO>>.Error("Failed to retrieve books: " + ex.Message);            }        }        public async Task<Result<BookDTO>> GetBookByIdAsync(int id)        {            try            {                // Try to get from cache first                string cacheKey = $"{BookCacheKeyPrefix}{id}";                if (_cache.TryGetValue(cacheKey, out BookDTO cachedBook))                {                    Log.Information("Retrieved book {BookId} from cache", id);                    return Result<BookDTO>.Success(cachedBook);                }                // If not in cache, get from database                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id);                                if (book == null)                {                    Log.Warning("Book with ID {BookId} not found", id);                    return Result<BookDTO>.NotFound($"Book with ID {id} not found");                }                var bookDto = _mapper.Map<BookDTO>(book);                // Store in cache for 5 minutes                var cacheOptions = new MemoryCacheEntryOptions()                    .SetAbsoluteExpiration(TimeSpan.FromMinutes(5));                                _cache.Set(cacheKey, bookDto, cacheOptions);                                Log.Information("Retrieved book {BookId} from database", id);                return Result<BookDTO>.Success(bookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error retrieving book with ID {BookId}", id);                return Result<BookDTO>.Error($"Failed to retrieve book with ID {id}: " + ex.Message);            }        }        public async Task<Result<BookDTO>> CreateBookAsync(BookInputDTO bookInput)        {            try            {                // Validate input                var validationResult = await _validator.ValidateAsync(bookInput);                if (!validationResult.IsValid)                {                    return Result<BookDTO>.Invalid(validationResult.Errors.Select(e =>                         new ValidationError { Identifier = e.PropertyName, ErrorMessage = e.ErrorMessage }).ToList());                }                // Map input to entity                var book = _mapper.Map<Book>(bookInput);                // Save to database                await _unitOfWork.Repository<Book>().AddAsync(book);                await _unitOfWork.CommitAsync();                // Map entity to DTO                var bookDto = _mapper.Map<BookDTO>(book);                // Invalidate the all books cache                _cache.Remove(BooksCacheKey);                Log.Information("New book created: {@Book}", bookDto);                return Result<BookDTO>.Success(bookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error creating book");                return Result<BookDTO>.Error("Failed to create book: " + ex.Message);            }        }        public async Task<Result<BookDTO>> UpdateBookAsync(int id, BookInputDTO bookInput)        {            try            {                // Validate input                var validationResult = await _validator.ValidateAsync(bookInput);                if (!validationResult.IsValid)                {                    return Result<BookDTO>.Invalid(validationResult.Errors.Select(e =>                         new ValidationError { Identifier = e.PropertyName, ErrorMessage = e.ErrorMessage }).ToList());                }                // Get existing book                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id);                if (book == null)                {                    Log.Warning("Book with ID {BookId} not found for update", id);                    return Result<BookDTO>.NotFound($"Book with ID {id} not found");                }                // Update properties                _mapper.Map(bookInput, book);                // Save changes                _unitOfWork.Repository<Book>().Update(book);                await _unitOfWork.CommitAsync();                // Map to DTO                var updatedBookDto = _mapper.Map<BookDTO>(book);                // Update cache                string cacheKey = $"{BookCacheKeyPrefix}{id}";                var cacheOptions = new MemoryCacheEntryOptions()                    .SetAbsoluteExpiration(TimeSpan.FromMinutes(5));                                _cache.Set(cacheKey, updatedBookDto, cacheOptions);                _cache.Remove(BooksCacheKey); // Invalidate all books cache                Log.Information("Book updated: {@Book}", updatedBookDto);                return Result<BookDTO>.Success(updatedBookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error updating book with ID {BookId}", id);                return Result<BookDTO>.Error($"Failed to update book with ID {id}: " + ex.Message);            }        }        public async Task<Result> DeleteBookAsync(int id)        {            try            {                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id);                if (book == null)                {                    Log.Warning("Book with ID {BookId} not found for deletion", id);                    return Result.NotFound($"Book with ID {id} not found");                }                _unitOfWork.Repository<Book>().Delete(book);                await _unitOfWork.CommitAsync();                // Remove from cache                string cacheKey = $"{BookCacheKeyPrefix}{id}";                _cache.Remove(cacheKey);                _cache.Remove(BooksCacheKey); // Invalidate all books cache                Log.Information("Book with ID {BookId} deleted", id);                return Result.Success();            }            catch (Exception ex)            {                Log.Error(ex, "Error deleting book with ID {BookId}", id);                return Result.Error($"Failed to delete book with ID {id}: " + ex.Message);            }        }    }}