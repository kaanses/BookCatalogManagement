// Services/BookService.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using Microsoft.Extensions.Caching.Memory;using Microsoft.Extensions.Configuration;using Mvc.BookManagement.Models.DTOs;using Mvc.BookManagement.Interfaces;using Serilog;using Mvc.BookManagement.Models.Entities;using Mvc.BookManagement.Helpers;using System.Collections.Generic;namespace Mvc.BookManagement.Services{    public class BookService : IBookService    {        private readonly IUnitOfWork _unitOfWork;        private readonly IMapper _mapper;        private readonly IValidator<BookInputDTO> _validator;        private readonly IMemoryCache _cache;        private readonly string _allBooksKey;        public BookService(            IUnitOfWork unitOfWork,             IMapper mapper,             IValidator<BookInputDTO> validator,            IMemoryCache cache,            IConfiguration configuration)        {            _unitOfWork = unitOfWork;            _mapper = mapper;            _validator = validator;            _cache = cache;            _allBooksKey = configuration["Cache:AllBooksKey"] ?? "AllBooks";        }        public async Task<Result<IEnumerable<BookDTO>>> GetAllBooksAsync()        {            try            {                // Try to get from cache first                if (_cache.TryGetValue(_allBooksKey, out IEnumerable<BookDTO> cachedBooks))                {                    Log.Information("Retrieved books from cache");                    return Result<IEnumerable<BookDTO>>.Success(cachedBooks);                }                // If not in cache, get from database                var books = await _unitOfWork.Repository<Book>().GetAllAsync();                var bookDtos = _mapper.Map<IEnumerable<BookDTO>>(books);                                // Store in cache                _cache.Set(_allBooksKey, bookDtos, CacheHelper.GetDefaultCacheOptions());                                Log.Information("Retrieved all books from database");                return Result<IEnumerable<BookDTO>>.Success(bookDtos);            }            catch (Exception ex)            {                Log.Error(ex, "Error retrieving all books");                return Result<IEnumerable<BookDTO>>.Error("Failed to retrieve books: " + ex.Message);            }        }        public async Task<Result<BookDTO>> GetBookByIdAsync(int id)        {            try            {                // Try to get from cache first                if (_cache.TryGetValue(_allBooksKey, out IEnumerable<BookDTO> cachedBooks))                {                    var cachedBook = cachedBooks.FirstOrDefault(b => b.Id == id);                    if (cachedBook != null)                    {                        Log.Information("Retrieved book {BookId} from cache", id);                        return Result<BookDTO>.Success(cachedBook);                    }                }                // If not in cache, get from database                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id);                                if (book == null)                {                    Log.Warning("Book with ID {BookId} not found", id);                    return Result<BookDTO>.NotFound($"Book with ID {id} not found");                }                var bookDto = _mapper.Map<BookDTO>(book);                                // Update all books cache if it exists                if (_cache.TryGetValue(_allBooksKey, out IEnumerable<BookDTO> existingBooks))                {                    // If the book isn't in the cache already, add it                    if (!existingBooks.Any(b => b.Id == id))                    {                        var updatedBooks = new List<BookDTO>(existingBooks) { bookDto };                        _cache.Set(_allBooksKey, updatedBooks, CacheHelper.GetDefaultCacheOptions());                    }                }                // Otherwise, just create a new cache with this single book                else                {                    _cache.Set(_allBooksKey, new List<BookDTO> { bookDto }, CacheHelper.GetDefaultCacheOptions());                }                                Log.Information("Retrieved book {BookId} from database", id);                return Result<BookDTO>.Success(bookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error retrieving book with ID {BookId}", id);                return Result<BookDTO>.Error($"Failed to retrieve book with ID {id}: " + ex.Message);            }        }        public async Task<Result<BookDTO>> CreateBookAsync(BookInputDTO bookInput)        {            try            {                // Validate input                var validationResult = await ValidationHelper.ValidateAsync(_validator, bookInput);                if (!validationResult.IsSuccess)                {                    return Result<BookDTO>.Invalid(validationResult.ValidationErrors);                }                // Map input to entity                var book = _mapper.Map<Book>(bookInput);                // Save to database                await _unitOfWork.Repository<Book>().AddAsync(book);                await _unitOfWork.CommitAsync();                // Map entity to DTO                var bookDto = _mapper.Map<BookDTO>(book);                // Update all books cache if it exists                if (_cache.TryGetValue(_allBooksKey, out IEnumerable<BookDTO> cachedBooks))                {                    var updatedBooksList = new List<BookDTO>(cachedBooks) { bookDto };                    _cache.Set(_allBooksKey, updatedBooksList, CacheHelper.GetDefaultCacheOptions());                }                Log.Information("New book created: {@Book}", bookDto);                return Result<BookDTO>.Success(bookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error creating book");                return Result<BookDTO>.Error("Failed to create book: " + ex.Message);            }        }        public async Task<Result<BookDTO>> UpdateBookAsync(int id, BookInputDTO bookInput)        {            try            {                // Validate input                var validationResult = await ValidationHelper.ValidateAsync(_validator, bookInput);                if (!validationResult.IsSuccess)                {                    return Result<BookDTO>.Invalid(validationResult.ValidationErrors);                }                // Get existing book                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id);                if (book == null)                {                    Log.Warning("Book with ID {BookId} not found for update", id);                    return Result<BookDTO>.NotFound($"Book with ID {id} not found");                }                // Update properties                _mapper.Map(bookInput, book);                // Save changes                _unitOfWork.Repository<Book>().Update(book);                await _unitOfWork.CommitAsync();                // Map to DTO                var updatedBookDto = _mapper.Map<BookDTO>(book);                // Update all books cache if it exists                if (_cache.TryGetValue(_allBooksKey, out IEnumerable<BookDTO> cachedBooks))                {                    var booksList = cachedBooks.ToList();                    var existingIndex = booksList.FindIndex(b => b.Id == id);                    if (existingIndex >= 0)                    {                        booksList[existingIndex] = updatedBookDto;                        _cache.Set(_allBooksKey, booksList, CacheHelper.GetDefaultCacheOptions());                    }                }                                Log.Information("Book updated: {@Book}", updatedBookDto);                return Result<BookDTO>.Success(updatedBookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error updating book with ID {BookId}", id);                return Result<BookDTO>.Error($"Failed to update book with ID {id}: " + ex.Message);            }        }        public async Task<Result> DeleteBookAsync(int id)        {            try            {                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id);                if (book == null)                {                    Log.Warning("Book with ID {BookId} not found for deletion", id);                    return Result.NotFound($"Book with ID {id} not found");                }                _unitOfWork.Repository<Book>().Delete(book);                await _unitOfWork.CommitAsync();                // Update all books cache if it exists                if (_cache.TryGetValue(_allBooksKey, out IEnumerable<BookDTO> cachedBooks))                {                    var updatedBooks = cachedBooks.Where(b => b.Id != id).ToList();                    _cache.Set(_allBooksKey, updatedBooks, CacheHelper.GetDefaultCacheOptions());                }                Log.Information("Book with ID {BookId} deleted", id);                return Result.Success();            }            catch (Exception ex)            {                Log.Error(ex, "Error deleting book with ID {BookId}", id);                return Result.Error($"Failed to delete book with ID {id}: " + ex.Message);            }        }    }}