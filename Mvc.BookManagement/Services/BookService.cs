using Ardalis.Result;using AutoMapper;using FluentValidation;using Microsoft.Extensions.Caching.Memory;using Mvc.BookManagement.Models.DTOs;using Mvc.BookManagement.Interfaces;using Serilog;using Mvc.BookManagement.Models.Entities;using Mvc.BookManagement.Helpers;namespace Mvc.BookManagement.Services{    public class BookService : IBookService    {        private readonly IUnitOfWork _unitOfWork;        private readonly IMapper _mapper;        private readonly IValidator<BookInputDTO> _validator;        private readonly IMemoryCache _cache;        private readonly string? _allBooksKey;        private readonly string? _bookKeyPrefix;        public BookService(            IUnitOfWork unitOfWork,             IMapper mapper,             IValidator<BookInputDTO> validator,            IMemoryCache cache,            IConfiguration configuration)        {            _unitOfWork = unitOfWork;            _mapper = mapper;            _validator = validator;            _cache = cache;            _allBooksKey = configuration["Cache:AllBooksKey"];            _bookKeyPrefix = configuration["Cache:BookKeyPrefix"];        }        public async Task<Result<IEnumerable<BookDTO>>> GetAllBooksAsync(CancellationToken cancellationToken = default)        {            try            {                if (_cache.TryGetValue(_allBooksKey, out IEnumerable<BookDTO> cachedBooks))                {                    Log.Information("Retrieved all books from cache");                    return Result<IEnumerable<BookDTO>>.Success(cachedBooks);                }                var books = await _unitOfWork.Repository<Book>().GetAllAsync(cancellationToken);                var bookDtos = _mapper.Map<IEnumerable<BookDTO>>(books);                                _cache.Set(_allBooksKey, bookDtos, CacheHelper.GetDefaultCacheOptions());                                Log.Information("Retrieved all books from database");                return Result<IEnumerable<BookDTO>>.Success(bookDtos);            }            catch (Exception ex)            {                Log.Error(ex, "Error retrieving all books");                return Result<IEnumerable<BookDTO>>.Error("Failed to retrieve books: " + ex.Message);            }        }        public async Task<Result<BookDTO>> GetBookByIdAsync(int id, CancellationToken cancellationToken = default)        {            try            {                if (_cache.TryGetValue($"Book:{id}", out BookDTO cachedBook))                {                    Log.Information("Retrieved book with ID  {BookId} from cache", id);                    return Result<BookDTO>.Success(cachedBook);                }                                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id, cancellationToken);                                if (book == null)                {                    Log.Information("Book with ID {BookId} not found", id);                    return Result<BookDTO>.NotFound($"Book with ID {id} not found");                }                var bookDto = _mapper.Map<BookDTO>(book);                _cache.Set($"{_bookKeyPrefix}{id}", bookDto, CacheHelper.GetDefaultCacheOptions());                                Log.Information("Retrieved book {BookId} from database", id);                return Result<BookDTO>.Success(bookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error retrieving book with ID {BookId}", id);                return Result<BookDTO>.Error($"Failed to retrieve book with ID {id}: " + ex.Message);            }        }        public async Task<Result<BookDTO>> CreateBookAsync(BookInputDTO bookInput, CancellationToken cancellationToken = default)        {            try            {                var validationResult = await ValidationHelper.ValidateAsync(_validator, bookInput);                if (!validationResult.IsSuccess)                {                    return Result<BookDTO>.Invalid(validationResult.ValidationErrors);                }                var book = _mapper.Map<Book>(bookInput);                await _unitOfWork.Repository<Book>().AddAsync(book, cancellationToken);                await _unitOfWork.CommitAsync(cancellationToken);                var bookDto = _mapper.Map<BookDTO>(book);                _cache.Set($"{_bookKeyPrefix}{bookDto.Id}", bookDto, CacheHelper.GetDefaultCacheOptions());                _cache.Remove(_allBooksKey);                Log.Information("New book created: {@Book}", bookDto);                return Result<BookDTO>.Success(bookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error creating book");                return Result<BookDTO>.Error("Failed to create book: " + ex.Message);            }        }        public async Task<Result<BookDTO>> UpdateBookAsync(int id, BookInputDTO bookInput, CancellationToken cancellationToken = default)        {            try            {                var validationResult = await ValidationHelper.ValidateAsync(_validator, bookInput);                if (!validationResult.IsSuccess)                {                    return Result<BookDTO>.Invalid(validationResult.ValidationErrors);                }                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id, cancellationToken);                if (book == null)                {                    Log.Information("Book with ID {BookId} not found for update", id);                    return Result<BookDTO>.NotFound($"Book with ID {id} not found");                }                _mapper.Map(bookInput, book);                _unitOfWork.Repository<Book>().Update(book);                await _unitOfWork.CommitAsync(cancellationToken);                var updatedBookDto = _mapper.Map<BookDTO>(book);                _cache.Set($"{_bookKeyPrefix}{id}", updatedBookDto, CacheHelper.GetDefaultCacheOptions());                _cache.Remove(_allBooksKey);                                Log.Information("Book updated: {@Book}", updatedBookDto);                return Result<BookDTO>.Success(updatedBookDto);            }            catch (Exception ex)            {                Log.Error(ex, "Error updating book with ID {BookId}", id);                return Result<BookDTO>.Error($"Failed to update book with ID {id}: " + ex.Message);            }        }        public async Task<Result> DeleteBookAsync(int id, CancellationToken cancellationToken = default)        {            try            {                var book = await _unitOfWork.Repository<Book>().GetByIdAsync(id, cancellationToken);                if (book == null)                {                    Log.Warning("Book with ID {BookId} not found for deletion", id);                    return Result.NotFound($"Book with ID {id} not found");                }                _unitOfWork.Repository<Book>().Delete(book);                await _unitOfWork.CommitAsync(cancellationToken);                _cache.Remove($"{_bookKeyPrefix}{id}");                _cache.Remove(_allBooksKey);                                Log.Information("Book with ID {BookId} deleted", id);                return Result.Success();            }            catch (Exception ex)            {                Log.Error(ex, "Error deleting book with ID {BookId}", id);                return Result.Error($"Failed to delete book with ID {id}: " + ex.Message);            }        }    }}